1. 데이터의 값과 Hash함수에 의해 삽입 위치가 결정되는 자료구조, 충돌의 경우를 무시한다면 삽입,삭제,검색에 O(1)만이 소요됨
2. 좌측의 경우 이름의 철자 수가 곧 해당 데이터의 위치가 됨 -> Hash 함수 h(x) = (영문명 기준 x의 철자 수)
**mod 연산을 이용한 Hash 함수의 구성**
- 준 HashTable 의 크기가 m 일 때 다음 Hash 함수를 생각 할 수 있음 h(x) = xmodm
**적재율**
- Hash Table의 크기가 m이고 저장된 데이터 수가 N 일 경우 (적재율) = n/m	
#### 충돌 해결
- Hash Table설계 시, 최대한 데이터가 고르게 분산되도록 적절한 Hash 함수를 택해야 함, 그러나, 최선의 Hash 함수를 택하였다 하더라도 충돌 자체를 피하기는 어려움
- Hash Table의 고유의 높은 성능을 최대한 유지할 수 있도록, 충돌해결 방안을 마련하면?
**해결방안**
1. Chaining을 이용한 충돌 회피 : 삽입하고자 하는 위치에 이미 데이터가 존재할 경우, Linked List등을 이용하여 동일한 위치에 데이터를 연달아 삽입함으로써 충돌 문제를 해결 할 수 있음
2. Linear Probing을 이용한 충돌 회피 : 선형적으로 빈칸을 탐색하는 방식의 Hash Table 충돌 회피 기법, 삽입하려 하는 곳이 비어 있지 않을 경우 ,다음 빈칸을 찾아 그곳에 데이터를 대신 적재, 이처럼, 데이터 적재 위치가 비어 있지 않은 경우 위치를 옮기는 방식을 Open Addressing이라 함

**Linear Probing을 이용한 충돌 회피 문제점**
1. 당초 위 푸른색 칸에는 90이 위치 하였으나, 데이터 삭제로 인해 현재는 비어있음
2. 이제 위와 같은 Hash Table에 38이라는 값이 존재하는지 확인하고자 함
3. h(38) = 12이므로 해당 위치에서부터 선형적으로 탐색, 탐색 중 빈칸을 만나게 되므로, 위 Hash Table에는 38이라는 값이 존재하지 않는다?
**Quadratic Probing을 이용한 충돌 회피**
1. 삽입 하려 하는 곳이 비어 있지 않을 경우, 다음 규칙 하에 빈칸을 찾아 그곳에 데이터를 대신 적재
	1. 원래 위치 1칸 뒤를 탐색
	2. 원래 위치 4칸 뒤를 탐색
	3. 원래 위치 9칸 뒤를 탐색
	4. 
**Double Hashing을 이용한 충돌 회피**
1. 일차적으로 h(x)를 이용하여 데이터를 삽입할 위치를 결정
2. 충돌 발생 시 추가 함수 f(x)를 이용, 건너뛸 칸 수를 결정한 후 빈칸을 찾을 때까지 건너뛰기 반복
3. 서로 다른 수 a와 b에 대하여, h(a) = h(b)이더라도 f(a)와 f(b)가 다를 수 있다는 점을 주목


