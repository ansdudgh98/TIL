### 정적 배열과 동적배열
- 정적 배열
	- 자구조의  한 형태인 배열에 속하며 그 중에서도 크기가 고정 되어 있는 것(크기를 미리 선언)
	- 배열의  특징인  (1) 인덱스를 활용한 접근, (2) 원소간 순서 구분을 공유
- 동적  배열
	- 자료구조의  한 형태인 배열에 속하며, 그중에도 정적 배열과는 달리 크기가 가변적인 것
	- 배열의 공간이 부족해 질 경우, 크기를 두배 늘리는 방식으로 데이터를 제어
	- 정적 배열과 동일하 인덱스를 활용해 데이터에 접근할  수 있으며 원소간 순서는 구분됨
- 동적 배열에서의 데이터 접근
	- 배열은 인덱스를 이용하므로, 인덱스 값을 알면 곧장 데이터 값을 얻을 수  있음
	- 다시 말해, 데이터 접근 시간은 데이터 크기 n과 무관하므로 시간 복잡도는 0(1)
- 동적 배열에서의 데이터 말단 삽입
	- 다른 데이터들과는 무관하게  빈 자리들의 맨 앞에서 데이터를 삽입하면 되므로 시간복잡도는 데이터 크기 n과 무관하며 O(1)
- 동적 배열에서의 데이터 임의 위치 삽입
	- 말단이 아닌 위치에 데이터를 삽입하려 하는 경우, 뒤쪽 데이터들을 모두 한 칸씩 밀어야만 원하는 삽입이 가능하므로 최악의 경우 n개의 기존 데이터를 모두 밀어야  할 수 있음
	- 따라서 최악의 경우를 살정했을때 데이터 임의 위치 합입에 대한 시간복잡도는 O(n)
- 동적 배열 에서의 데이터 삭제
	- (말단 삭제) 삽입에서와 유사하게 다른 데이터에 영향을 주지 않으므로, 시간복잡도는 O(1)
	- (임의 위치 삭제) 삭제 대상 우측의 데이터가 모두 밀리므로 최악의 경우 시간복잡도는 O(n)
### Linked List
- 연결형 자료구조의 하나로 각각의 데이터가 다음 데이터를 가리키는 형태의 자료구조
- 각각의 원소는 Node라고 칭하며, 하나의 Node는 data값과 next 대상을 지님
- 편의상 Linked List의 시작과 끝에는 data 값을 가지지 않는 더미 Node를 배치
**데이터 삽입**
- 어떤 위치에 데이터를 삽입 하려하든, 다음의 두 과정만을 거치면 삽입이 완료될 수 밖에 없음
 (1) 신규 Node의 data와 next를 지정 (2) 직전 Node의 next대상을 신규 Node로 변경
- 이 과정은 데이터 크기에 구애받지 않으므로, 시간복잡도는 O(1)
**데이터 삭제**
- 어떤 위치에 존재하는 데이터를 삭제하려 하든, 다음의 두 과정만을 거치면 삭제가 완료됨
 (1) 삭제 대상 직전 Node의 next를 조정 (2) 삭제 대상 Node를 실제로 제거
 - 삭제 대상 직전 Node를 이미 안다는 가정하에 시간복잡도는 O(1) 
**데이터 접근**
- 더미 제외 N개의 Node가 존재하는 어떤 Linked List에서 N번째 데이터에 접근 하기 위해서는 모든 Node를 돌아야 함 -> 최악의 상황에서 접근 시간복잡도는 O(N) -> LinkedList의 단점
### 양방향 LinkedList(Doubly Linked List)
- 연결형 자료구조의 하나로, 각각의 데이터가 이전 및 다음 데이터를 가리키는 형태의 자료구조
- 각각의 원소는 Node라고 칭하며, 하나의 Node는 data값과 prev 및 next대상을 지님
- 단방향에서와 유사하게 편의상 시작과 끝에는 data 값을 가지지 않는 더미 Node를 배치
**데이터 삭제**
(1) 삭제 대상 데이터 직전 Node의 next를 조정  (2) 삭제 대상 데이터 직후 Node의 prev를 조정
(3) 삭제 대상 Node를 실제적으로 제거
- 단방향 떄와 달리 삭제 대상 데이터 직전 Node의 정보를 곧장 얻을 수 있음
### 원형 Linked List(Circular Linked List)
- Linked List에서 순서상 맨 마지막 Node를 가진 갖아 첫 Node와 이어 사이클을 만든 자료구조
- 순서상 뒤에 있는 Node도, 순회 과정을 거져 순서상 앞에 있는 Node까지 이어질 수 있음
### Doubly Circular Linked List
- Doubly Linked List에서 순서상 맨 마지막 Node를 가장 첫 Node와 이어 사이클을 만든 자료구조
